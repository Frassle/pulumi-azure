// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Linq;

namespace Pulumi.Azure.Compute {

	/// <summary>
	/// The set of arguments for constructing a Extension resource.
	/// </summary>
	public struct ExtensionArgs {
		/// <summary>
		/// Specifies if the platform deploys
		/// the latest minor version update to the `type_handler_version` specified.
		/// </summary>
		public Pulumi.IO<bool> AutoUpgradeMinorVersion { get; set; }

		/// <summary>
		/// The location where the extension is created. Changing
		/// this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Location { get; set; }

		/// <summary>
		/// The name of the virtual machine extension peering. Changing
		/// this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Name { get; set; }

		/// <summary>
		/// The protected_settings passed to the
		/// extension, like settings, these are specified as a JSON object in a string.
		/// </summary>
		public Pulumi.IO<string> ProtectedSettings { get; set; }

		/// <summary>
		/// The publisher of the extension, available publishers
		/// can be found by using the Azure CLI.
		/// </summary>
		public Pulumi.IO<string> Publisher { get; set; }

		/// <summary>
		/// The name of the resource group in which to
		/// create the virtual network. Changing this forces a new resource to be
		/// created.
		/// </summary>
		public Pulumi.IO<string> ResourceGroupName { get; set; }

		/// <summary>
		/// The settings passed to the extension, these are
		/// specified as a JSON object in a string.
		/// </summary>
		public Pulumi.IO<string> Settings { get; set; }

		/// <summary>
		/// A mapping of tags to assign to the resource.
		/// </summary>
		public Pulumi.IO<System.Collections.Generic.Dictionary<string, string>> Tags { get; set; }

		/// <summary>
		/// The type of extension, available types for a publisher can
		/// be found using the Azure CLI.
		/// </summary>
		public Pulumi.IO<string> Type { get; set; }

		/// <summary>
		/// Specifies the version of the extension to
		/// use, available versions can be found using the Azure CLI.
		/// </summary>
		public Pulumi.IO<string> TypeHandlerVersion { get; set; }

		/// <summary>
		/// The name of the virtual machine. Changing
		/// this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> VirtualMachineName { get; set; }

	} // ExtensionArgs

	/// <summary>
	/// Manages a Virtual Machine Extension to provide post deployment configuration
	/// and run automated tasks.
	/// 
	/// > **NOTE:** Custom Script Extensions for Linux & Windows require that the `commandToExecute` returns a `0` exit code to be classified as successfully deployed. You can achieve this by appending `exit 0` to the end of your `commandToExecute`.
	/// 
	/// -> **NOTE:** Custom Script Extensions require that the Azure Virtual Machine Guest Agent is running on the Virtual Machine.
	/// </summary>
	public class Extension : Pulumi.CustomResource {
		/// <summary>
		/// Specifies if the platform deploys
		/// the latest minor version update to the `type_handler_version` specified.
		/// </summary>
		public Pulumi.IO<bool> AutoUpgradeMinorVersion { get; set; }

		/// <summary>
		/// The location where the extension is created. Changing
		/// this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Location { get; set; }

		/// <summary>
		/// The name of the virtual machine extension peering. Changing
		/// this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Name { get; set; }

		/// <summary>
		/// The protected_settings passed to the
		/// extension, like settings, these are specified as a JSON object in a string.
		/// </summary>
		public Pulumi.IO<string> ProtectedSettings { get; set; }

		/// <summary>
		/// The publisher of the extension, available publishers
		/// can be found by using the Azure CLI.
		/// </summary>
		public Pulumi.IO<string> Publisher { get; set; }

		/// <summary>
		/// The name of the resource group in which to
		/// create the virtual network. Changing this forces a new resource to be
		/// created.
		/// </summary>
		public Pulumi.IO<string> ResourceGroupName { get; set; }

		/// <summary>
		/// The settings passed to the extension, these are
		/// specified as a JSON object in a string.
		/// </summary>
		public Pulumi.IO<string> Settings { get; set; }

		/// <summary>
		/// A mapping of tags to assign to the resource.
		/// </summary>
		public Pulumi.IO<System.Collections.Generic.Dictionary<string, string>> Tags { get; set; }

		/// <summary>
		/// The type of extension, available types for a publisher can
		/// be found using the Azure CLI.
		/// </summary>
		public Pulumi.IO<string> Type { get; set; }

		/// <summary>
		/// Specifies the version of the extension to
		/// use, available versions can be found using the Azure CLI.
		/// </summary>
		public Pulumi.IO<string> TypeHandlerVersion { get; set; }

		/// <summary>
		/// The name of the virtual machine. Changing
		/// this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> VirtualMachineName { get; set; }

		public Extension(string name, ExtensionArgs args, Pulumi.ResourceOptions opts = default(Pulumi.ResourceOptions))
			: base("azure:compute/extension:Extension", name, SerialiseArgs(args), opts) {
			AutoUpgradeMinorVersion = base.Outputs["autoUpgradeMinorVersion"].Select(item => Protobuf.ToBool(item));
			Location = base.Outputs["location"].Select(item => Protobuf.ToString(item));
			Name = base.Outputs["name"].Select(item => Protobuf.ToString(item));
			ProtectedSettings = base.Outputs["protectedSettings"].Select(item => Protobuf.ToString(item));
			Publisher = base.Outputs["publisher"].Select(item => Protobuf.ToString(item));
			ResourceGroupName = base.Outputs["resourceGroupName"].Select(item => Protobuf.ToString(item));
			Settings = base.Outputs["settings"].Select(item => Protobuf.ToString(item));
			Tags = base.Outputs["tags"].Select(item => Protobuf.ToMap(item));
			Type = base.Outputs["type"].Select(item => Protobuf.ToString(item));
			TypeHandlerVersion = base.Outputs["typeHandlerVersion"].Select(item => Protobuf.ToString(item));
			VirtualMachineName = base.Outputs["virtualMachineName"].Select(item => Protobuf.ToString(item));
		} // ctor

		private static Dictionary<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>> SerialiseArgs(ExtensionArgs args) {
			var props = new Dictionary<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>();
			props["autoUpgradeMinorVersion"] = Protobuf.ToProtobuf(args.AutoUpgradeMinorVersion);
			props["location"] = Protobuf.ToProtobuf(args.Location);
			props["name"] = Protobuf.ToProtobuf(args.Name);
			props["protectedSettings"] = Protobuf.ToProtobuf(args.ProtectedSettings);
			props["publisher"] = Protobuf.ToProtobuf(args.Publisher);
			props["resourceGroupName"] = Protobuf.ToProtobuf(args.ResourceGroupName);
			props["settings"] = Protobuf.ToProtobuf(args.Settings);
			props["tags"] = Protobuf.ToProtobuf(args.Tags);
			props["type"] = Protobuf.ToProtobuf(args.Type);
			props["typeHandlerVersion"] = Protobuf.ToProtobuf(args.TypeHandlerVersion);
			props["virtualMachineName"] = Protobuf.ToProtobuf(args.VirtualMachineName);
			return props;
		} // SerialiseArgs

	} // Extension
} // Pulumi.Azure.Compute
