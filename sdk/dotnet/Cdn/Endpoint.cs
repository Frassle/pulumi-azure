// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Linq;

namespace Pulumi.Azure.Cdn {

	public sealed class EndpointArgsGeoFilter : Pulumi.IIOProtobuf {
		public Pulumi.IO<string> Action { get; set; }
		public Pulumi.IO<Pulumi.IO<string>[]> CountryCodes { get; set; }
		public Pulumi.IO<string> RelativePath { get; set; }

		public Pulumi.IO<Google.Protobuf.WellKnownTypes.Value> ToProtobuf() {
			return Protobuf.ToProtobuf(
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("action", Protobuf.ToProtobuf(Action)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("country_codes", Protobuf.ToProtobuf(CountryCodes, item => Protobuf.ToProtobuf(item))),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("relative_path", Protobuf.ToProtobuf(RelativePath)));
		} // ToProtobuf

	} // EndpointArgsGeoFilter

	public sealed class EndpointArgsOrigin : Pulumi.IIOProtobuf {
		public Pulumi.IO<string> HostName { get; set; }
		public Pulumi.IO<int> HttpPort { get; set; }
		public Pulumi.IO<int> HttpsPort { get; set; }
		public Pulumi.IO<string> Name { get; set; }

		public Pulumi.IO<Google.Protobuf.WellKnownTypes.Value> ToProtobuf() {
			return Protobuf.ToProtobuf(
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("host_name", Protobuf.ToProtobuf(HostName)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("http_port", Protobuf.ToProtobuf(HttpPort)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("https_port", Protobuf.ToProtobuf(HttpsPort)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("name", Protobuf.ToProtobuf(Name)));
		} // ToProtobuf

	} // EndpointArgsOrigin

	public sealed class EndpointGeoFilter : Pulumi.IIOProtobuf {
		public Pulumi.IO<string> Action { get; set; }
		public Pulumi.IO<string[]> CountryCodes { get; set; }
		public Pulumi.IO<string> RelativePath { get; set; }

		public Pulumi.IO<Google.Protobuf.WellKnownTypes.Value> ToProtobuf() {
			return Protobuf.ToProtobuf(
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("action", Protobuf.ToProtobuf(Action)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("country_codes", Protobuf.ToProtobuf(CountryCodes, item => Protobuf.ToProtobuf(item))),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("relative_path", Protobuf.ToProtobuf(RelativePath)));
		} // ToProtobuf

		public static EndpointGeoFilter FromProtobuf(Google.Protobuf.WellKnownTypes.Value value) {
			var obj = value.StructValue;
			var result = new EndpointGeoFilter();
				if (obj.Fields.ContainsKey("action")) {
					result.Action = Protobuf.ToString(obj.Fields["action"]);
				}
				if (obj.Fields.ContainsKey("country_codes")) {
					result.CountryCodes = Protobuf.ToList(obj.Fields["country_codes"], item => Protobuf.ToString(item));
				}
				if (obj.Fields.ContainsKey("relative_path")) {
					result.RelativePath = Protobuf.ToString(obj.Fields["relative_path"]);
				}
			return result;
		} // FromProtobuf

	} // EndpointGeoFilter

	public sealed class EndpointOrigin : Pulumi.IIOProtobuf {
		public Pulumi.IO<string> HostName { get; set; }
		public Pulumi.IO<int> HttpPort { get; set; }
		public Pulumi.IO<int> HttpsPort { get; set; }
		public Pulumi.IO<string> Name { get; set; }

		public Pulumi.IO<Google.Protobuf.WellKnownTypes.Value> ToProtobuf() {
			return Protobuf.ToProtobuf(
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("host_name", Protobuf.ToProtobuf(HostName)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("http_port", Protobuf.ToProtobuf(HttpPort)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("https_port", Protobuf.ToProtobuf(HttpsPort)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("name", Protobuf.ToProtobuf(Name)));
		} // ToProtobuf

		public static EndpointOrigin FromProtobuf(Google.Protobuf.WellKnownTypes.Value value) {
			var obj = value.StructValue;
			var result = new EndpointOrigin();
				if (obj.Fields.ContainsKey("host_name")) {
					result.HostName = Protobuf.ToString(obj.Fields["host_name"]);
				}
				if (obj.Fields.ContainsKey("http_port")) {
					result.HttpPort = Protobuf.ToInt(obj.Fields["http_port"]);
				}
				if (obj.Fields.ContainsKey("https_port")) {
					result.HttpsPort = Protobuf.ToInt(obj.Fields["https_port"]);
				}
				if (obj.Fields.ContainsKey("name")) {
					result.Name = Protobuf.ToString(obj.Fields["name"]);
				}
			return result;
		} // FromProtobuf

	} // EndpointOrigin

	/// <summary>
	/// The set of arguments for constructing a Endpoint resource.
	/// </summary>
	public struct EndpointArgs {
		/// <summary>
		/// An array of strings that indicates a content types on which compression will be applied. The value for the elements should be MIME types.
		/// </summary>
		public Pulumi.IO<Pulumi.IO<string>[]> ContentTypesToCompresses { get; set; }

		/// <summary>
		/// A set of Geo Filters for this CDN Endpoint. Each `geo_filter` block supports fields documented below.
		/// </summary>
		public Pulumi.IO<Pulumi.IO<EndpointArgsGeoFilter>[]> GeoFilters { get; set; }

		/// <summary>
		/// Indicates whether compression is to be enabled. Defaults to false.
		/// </summary>
		public Pulumi.IO<bool> IsCompressionEnabled { get; set; }

		/// <summary>
		/// Defaults to `true`.
		/// </summary>
		public Pulumi.IO<bool> IsHttpAllowed { get; set; }

		/// <summary>
		/// Defaults to `true`.
		/// </summary>
		public Pulumi.IO<bool> IsHttpsAllowed { get; set; }

		/// <summary>
		/// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Location { get; set; }

		/// <summary>
		/// Specifies the name of the CDN Endpoint. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Name { get; set; }

		/// <summary>
		/// What types of optimization should this CDN Endpoint optimize for? Possible values include `DynamicSiteAcceleration`, `GeneralMediaStreaming`, `GeneralWebDelivery`, `LargeFileDownload` and `VideoOnDemandMediaStreaming`.
		/// </summary>
		public Pulumi.IO<string> OptimizationType { get; set; }

		/// <summary>
		/// The set of origins of the CDN endpoint. When multiple origins exist, the first origin will be used as primary and rest will be used as failover options. Each `origin` block supports fields documented below.
		/// </summary>
		public Pulumi.IO<Pulumi.IO<EndpointArgsOrigin>[]> Origins { get; set; }

		/// <summary>
		/// The host header CDN provider will send along with content requests to origins. Defaults to the host name of the origin.
		/// </summary>
		public Pulumi.IO<string> OriginHostHeader { get; set; }

		/// <summary>
		/// The path used at for origin requests.
		/// </summary>
		public Pulumi.IO<string> OriginPath { get; set; }

		/// <summary>
		/// the path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the most optimal routes for the CDN. This is relative to the `origin_path`.
		/// </summary>
		public Pulumi.IO<string> ProbePath { get; set; }

		/// <summary>
		/// The CDN Profile to which to attach the CDN Endpoint.
		/// </summary>
		public Pulumi.IO<string> ProfileName { get; set; }

		/// <summary>
		/// Sets query string caching behavior. Allowed values are `IgnoreQueryString`, `BypassCaching` and `UseQueryString`. Defaults to `IgnoreQueryString`.
		/// </summary>
		public Pulumi.IO<string> QuerystringCachingBehaviour { get; set; }

		/// <summary>
		/// The name of the resource group in which to create the CDN Endpoint.
		/// </summary>
		public Pulumi.IO<string> ResourceGroupName { get; set; }

		/// <summary>
		/// A mapping of tags to assign to the resource.
		/// </summary>
		public Pulumi.IO<System.Collections.Generic.Dictionary<string, string>> Tags { get; set; }

	} // EndpointArgs

	/// <summary>
	/// A CDN Endpoint is the entity within a CDN Profile containing configuration information regarding caching behaviors and origins. The CDN Endpoint is exposed using the URL format <endpointname>.azureedge.net.
	/// </summary>
	public class Endpoint : Pulumi.CustomResource {
		/// <summary>
		/// An array of strings that indicates a content types on which compression will be applied. The value for the elements should be MIME types.
		/// </summary>
		public Pulumi.IO<string[]> ContentTypesToCompresses { get; set; }

		/// <summary>
		/// A set of Geo Filters for this CDN Endpoint. Each `geo_filter` block supports fields documented below.
		/// </summary>
		public Pulumi.IO<EndpointGeoFilter[]> GeoFilters { get; set; }

		public Pulumi.IO<string> HostName { get; set; }

		/// <summary>
		/// Indicates whether compression is to be enabled. Defaults to false.
		/// </summary>
		public Pulumi.IO<bool> IsCompressionEnabled { get; set; }

		/// <summary>
		/// Defaults to `true`.
		/// </summary>
		public Pulumi.IO<bool> IsHttpAllowed { get; set; }

		/// <summary>
		/// Defaults to `true`.
		/// </summary>
		public Pulumi.IO<bool> IsHttpsAllowed { get; set; }

		/// <summary>
		/// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Location { get; set; }

		/// <summary>
		/// Specifies the name of the CDN Endpoint. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Name { get; set; }

		/// <summary>
		/// What types of optimization should this CDN Endpoint optimize for? Possible values include `DynamicSiteAcceleration`, `GeneralMediaStreaming`, `GeneralWebDelivery`, `LargeFileDownload` and `VideoOnDemandMediaStreaming`.
		/// </summary>
		public Pulumi.IO<string> OptimizationType { get; set; }

		/// <summary>
		/// The set of origins of the CDN endpoint. When multiple origins exist, the first origin will be used as primary and rest will be used as failover options. Each `origin` block supports fields documented below.
		/// </summary>
		public Pulumi.IO<EndpointOrigin[]> Origins { get; set; }

		/// <summary>
		/// The host header CDN provider will send along with content requests to origins. Defaults to the host name of the origin.
		/// </summary>
		public Pulumi.IO<string> OriginHostHeader { get; set; }

		/// <summary>
		/// The path used at for origin requests.
		/// </summary>
		public Pulumi.IO<string> OriginPath { get; set; }

		/// <summary>
		/// the path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the most optimal routes for the CDN. This is relative to the `origin_path`.
		/// </summary>
		public Pulumi.IO<string> ProbePath { get; set; }

		/// <summary>
		/// The CDN Profile to which to attach the CDN Endpoint.
		/// </summary>
		public Pulumi.IO<string> ProfileName { get; set; }

		/// <summary>
		/// Sets query string caching behavior. Allowed values are `IgnoreQueryString`, `BypassCaching` and `UseQueryString`. Defaults to `IgnoreQueryString`.
		/// </summary>
		public Pulumi.IO<string> QuerystringCachingBehaviour { get; set; }

		/// <summary>
		/// The name of the resource group in which to create the CDN Endpoint.
		/// </summary>
		public Pulumi.IO<string> ResourceGroupName { get; set; }

		/// <summary>
		/// A mapping of tags to assign to the resource.
		/// </summary>
		public Pulumi.IO<System.Collections.Generic.Dictionary<string, string>> Tags { get; set; }

		public Endpoint(string name, EndpointArgs args, Pulumi.ResourceOptions opts = default(Pulumi.ResourceOptions))
			: base("azure:cdn/endpoint:Endpoint", name, SerialiseArgs(args), opts) {
			ContentTypesToCompresses = base.Outputs["contentTypesToCompresses"].Select(item => Protobuf.ToList(item, item1 => Protobuf.ToString(item1)));
			GeoFilters = base.Outputs["geoFilters"].Select(item => Protobuf.ToList(item, item1 => EndpointGeoFilter.FromProtobuf(item1)));
			HostName = base.Outputs["hostName"].Select(item => Protobuf.ToString(item));
			IsCompressionEnabled = base.Outputs["isCompressionEnabled"].Select(item => Protobuf.ToBool(item));
			IsHttpAllowed = base.Outputs["isHttpAllowed"].Select(item => Protobuf.ToBool(item));
			IsHttpsAllowed = base.Outputs["isHttpsAllowed"].Select(item => Protobuf.ToBool(item));
			Location = base.Outputs["location"].Select(item => Protobuf.ToString(item));
			Name = base.Outputs["name"].Select(item => Protobuf.ToString(item));
			OptimizationType = base.Outputs["optimizationType"].Select(item => Protobuf.ToString(item));
			Origins = base.Outputs["origins"].Select(item => Protobuf.ToList(item, item1 => EndpointOrigin.FromProtobuf(item1)));
			OriginHostHeader = base.Outputs["originHostHeader"].Select(item => Protobuf.ToString(item));
			OriginPath = base.Outputs["originPath"].Select(item => Protobuf.ToString(item));
			ProbePath = base.Outputs["probePath"].Select(item => Protobuf.ToString(item));
			ProfileName = base.Outputs["profileName"].Select(item => Protobuf.ToString(item));
			QuerystringCachingBehaviour = base.Outputs["querystringCachingBehaviour"].Select(item => Protobuf.ToString(item));
			ResourceGroupName = base.Outputs["resourceGroupName"].Select(item => Protobuf.ToString(item));
			Tags = base.Outputs["tags"].Select(item => Protobuf.ToMap(item));
		} // ctor

		private static Dictionary<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>> SerialiseArgs(EndpointArgs args) {
			var props = new Dictionary<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>();
			props["contentTypesToCompresses"] = Protobuf.ToProtobuf(args.ContentTypesToCompresses, item => Protobuf.ToProtobuf(item));
			props["geoFilters"] = Protobuf.ToProtobuf(args.GeoFilters, item => Protobuf.ToProtobuf(item));
			props["isCompressionEnabled"] = Protobuf.ToProtobuf(args.IsCompressionEnabled);
			props["isHttpAllowed"] = Protobuf.ToProtobuf(args.IsHttpAllowed);
			props["isHttpsAllowed"] = Protobuf.ToProtobuf(args.IsHttpsAllowed);
			props["location"] = Protobuf.ToProtobuf(args.Location);
			props["name"] = Protobuf.ToProtobuf(args.Name);
			props["optimizationType"] = Protobuf.ToProtobuf(args.OptimizationType);
			props["origins"] = Protobuf.ToProtobuf(args.Origins, item => Protobuf.ToProtobuf(item));
			props["originHostHeader"] = Protobuf.ToProtobuf(args.OriginHostHeader);
			props["originPath"] = Protobuf.ToProtobuf(args.OriginPath);
			props["probePath"] = Protobuf.ToProtobuf(args.ProbePath);
			props["profileName"] = Protobuf.ToProtobuf(args.ProfileName);
			props["querystringCachingBehaviour"] = Protobuf.ToProtobuf(args.QuerystringCachingBehaviour);
			props["resourceGroupName"] = Protobuf.ToProtobuf(args.ResourceGroupName);
			props["tags"] = Protobuf.ToProtobuf(args.Tags);
			props["hostName"] = null; //out
			return props;
		} // SerialiseArgs

	} // Endpoint
} // Pulumi.Azure.Cdn
