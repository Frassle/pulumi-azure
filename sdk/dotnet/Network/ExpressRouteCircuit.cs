// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Linq;

namespace Pulumi.Azure.Network {

	public sealed class ExpressRouteCircuitArgsSku : Pulumi.IIOProtobuf {
		public Pulumi.IO<string> Family { get; set; }
		public Pulumi.IO<string> Tier { get; set; }

		public Pulumi.IO<Google.Protobuf.WellKnownTypes.Value> ToProtobuf() {
			return Protobuf.ToProtobuf(
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("family", Protobuf.ToProtobuf(Family)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("tier", Protobuf.ToProtobuf(Tier)));
		} // ToProtobuf

	} // ExpressRouteCircuitArgsSku

	public sealed class ExpressRouteCircuitSku : Pulumi.IIOProtobuf {
		public Pulumi.IO<string> Family { get; set; }
		public Pulumi.IO<string> Tier { get; set; }

		public Pulumi.IO<Google.Protobuf.WellKnownTypes.Value> ToProtobuf() {
			return Protobuf.ToProtobuf(
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("family", Protobuf.ToProtobuf(Family)),
				new KeyValuePair<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>("tier", Protobuf.ToProtobuf(Tier)));
		} // ToProtobuf

		public static ExpressRouteCircuitSku FromProtobuf(Google.Protobuf.WellKnownTypes.Value value) {
			var obj = value.StructValue;
			var result = new ExpressRouteCircuitSku();
				if (obj.Fields.ContainsKey("family")) {
					result.Family = Protobuf.ToString(obj.Fields["family"]);
				}
				if (obj.Fields.ContainsKey("tier")) {
					result.Tier = Protobuf.ToString(obj.Fields["tier"]);
				}
			return result;
		} // FromProtobuf

	} // ExpressRouteCircuitSku

	/// <summary>
	/// The set of arguments for constructing a ExpressRouteCircuit resource.
	/// </summary>
	public struct ExpressRouteCircuitArgs {
		/// <summary>
		/// Allow the circuit to interact with classic (RDFE) resources. The default value is `false`.
		/// </summary>
		public Pulumi.IO<bool> AllowClassicOperations { get; set; }

		/// <summary>
		/// The bandwidth in Mbps of the circuit being created.
		/// </summary>
		public Pulumi.IO<int> BandwidthInMbps { get; set; }

		/// <summary>
		/// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Location { get; set; }

		/// <summary>
		/// The name of the ExpressRoute circuit. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Name { get; set; }

		/// <summary>
		/// The name of the peering location and **not** the Azure resource location.
		/// </summary>
		public Pulumi.IO<string> PeeringLocation { get; set; }

		/// <summary>
		/// The name of the resource group in which to create the ExpressRoute circuit. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> ResourceGroupName { get; set; }

		/// <summary>
		/// The name of the ExpressRoute Service Provider.
		/// </summary>
		public Pulumi.IO<string> ServiceProviderName { get; set; }

		/// <summary>
		/// A `sku` block for the ExpressRoute circuit as documented below.
		/// </summary>
		public Pulumi.IO<ExpressRouteCircuitArgsSku> Sku { get; set; }

		/// <summary>
		/// A mapping of tags to assign to the resource.
		/// </summary>
		public Pulumi.IO<System.Collections.Generic.Dictionary<string, string>> Tags { get; set; }

	} // ExpressRouteCircuitArgs

	/// <summary>
	/// Manages an ExpressRoute circuit.
	/// </summary>
	public class ExpressRouteCircuit : Pulumi.CustomResource {
		/// <summary>
		/// Allow the circuit to interact with classic (RDFE) resources. The default value is `false`.
		/// </summary>
		public Pulumi.IO<bool> AllowClassicOperations { get; set; }

		/// <summary>
		/// The bandwidth in Mbps of the circuit being created.
		/// </summary>
		public Pulumi.IO<int> BandwidthInMbps { get; set; }

		/// <summary>
		/// Specifies the supported Azure location where the resource exists. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Location { get; set; }

		/// <summary>
		/// The name of the ExpressRoute circuit. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> Name { get; set; }

		/// <summary>
		/// The name of the peering location and **not** the Azure resource location.
		/// </summary>
		public Pulumi.IO<string> PeeringLocation { get; set; }

		/// <summary>
		/// The name of the resource group in which to create the ExpressRoute circuit. Changing this forces a new resource to be created.
		/// </summary>
		public Pulumi.IO<string> ResourceGroupName { get; set; }

		/// <summary>
		/// The string needed by the service provider to provision the ExpressRoute circuit.
		/// </summary>
		public Pulumi.IO<string> ServiceKey { get; set; }

		/// <summary>
		/// The name of the ExpressRoute Service Provider.
		/// </summary>
		public Pulumi.IO<string> ServiceProviderName { get; set; }

		/// <summary>
		/// The ExpressRoute circuit provisioning state from your chosen service provider. Possible values are "NotProvisioned", "Provisioning", "Provisioned", and "Deprovisioning".
		/// </summary>
		public Pulumi.IO<string> ServiceProviderProvisioningState { get; set; }

		/// <summary>
		/// A `sku` block for the ExpressRoute circuit as documented below.
		/// </summary>
		public Pulumi.IO<ExpressRouteCircuitSku> Sku { get; set; }

		/// <summary>
		/// A mapping of tags to assign to the resource.
		/// </summary>
		public Pulumi.IO<System.Collections.Generic.Dictionary<string, string>> Tags { get; set; }

		public ExpressRouteCircuit(string name, ExpressRouteCircuitArgs args, Pulumi.ResourceOptions opts = default(Pulumi.ResourceOptions))
			: base("azure:network/expressRouteCircuit:ExpressRouteCircuit", name, SerialiseArgs(args), opts) {
			AllowClassicOperations = base.Outputs["allowClassicOperations"].Select(item => Protobuf.ToBool(item));
			BandwidthInMbps = base.Outputs["bandwidthInMbps"].Select(item => Protobuf.ToInt(item));
			Location = base.Outputs["location"].Select(item => Protobuf.ToString(item));
			Name = base.Outputs["name"].Select(item => Protobuf.ToString(item));
			PeeringLocation = base.Outputs["peeringLocation"].Select(item => Protobuf.ToString(item));
			ResourceGroupName = base.Outputs["resourceGroupName"].Select(item => Protobuf.ToString(item));
			ServiceKey = base.Outputs["serviceKey"].Select(item => Protobuf.ToString(item));
			ServiceProviderName = base.Outputs["serviceProviderName"].Select(item => Protobuf.ToString(item));
			ServiceProviderProvisioningState = base.Outputs["serviceProviderProvisioningState"].Select(item => Protobuf.ToString(item));
			Sku = base.Outputs["sku"].Select(item => ExpressRouteCircuitSku.FromProtobuf(item));
			Tags = base.Outputs["tags"].Select(item => Protobuf.ToMap(item));
		} // ctor

		private static Dictionary<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>> SerialiseArgs(ExpressRouteCircuitArgs args) {
			var props = new Dictionary<string, Pulumi.IO<Google.Protobuf.WellKnownTypes.Value>>();
			props["allowClassicOperations"] = Protobuf.ToProtobuf(args.AllowClassicOperations);
			props["bandwidthInMbps"] = Protobuf.ToProtobuf(args.BandwidthInMbps);
			props["location"] = Protobuf.ToProtobuf(args.Location);
			props["name"] = Protobuf.ToProtobuf(args.Name);
			props["peeringLocation"] = Protobuf.ToProtobuf(args.PeeringLocation);
			props["resourceGroupName"] = Protobuf.ToProtobuf(args.ResourceGroupName);
			props["serviceProviderName"] = Protobuf.ToProtobuf(args.ServiceProviderName);
			props["sku"] = Protobuf.ToProtobuf(args.Sku);
			props["tags"] = Protobuf.ToProtobuf(args.Tags);
			props["serviceKey"] = null; //out
			props["serviceProviderProvisioningState"] = null; //out
			return props;
		} // SerialiseArgs

	} // ExpressRouteCircuit
} // Pulumi.Azure.Network
